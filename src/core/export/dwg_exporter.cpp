#include "core/export/dwg_exporter.hpp"
#include <iostream>
#include <cmath>

DwgExporter::DwgExporter() {}

DwgExporter::~DwgExporter() {}

bool DwgExporter::exportToFile(const std::string& filename, const HeatingDesign& design) {
    writer = std::make_unique<dxfRW>(filename.c_str());
    currentDesign = design;
    
    // 开始写入DWG文件
    bool success = writer->write(this, DRW::AC1021, false);  // AC1021 corresponds to AutoCAD 2007
    if (!success) {
        std::cerr << "Error writing DWG file: " << filename << std::endl;
    }
    return success;
}

void DwgExporter::writeHeader(DRW_Header& data) {
    // 设置基本的图纸属性
    data.addComment("Generated by IAD HeatingDesign Exporter");
    data.addDouble("$INSUNITS", 4.0, 70); // 4 = millimeters
}

void DwgExporter::writeEntities() {
    // 导出所有地暖盘管
    for (const auto& coil : currentDesign.HeatingCoils) {
        exportHeatingCoil(coil);
    }
}

void DwgExporter::writeLTypes() {
    DRW_LType ltype;
    ltype.name = "CONTINUOUS";
    ltype.desc = "Solid line";
    writer->writeLineType(&ltype);
}

void DwgExporter::writeLayers() {
    DRW_Layer layer;
    
    // 创建盘管回路图层
    layer.name = "CoilLoop";
    layer.lineType = "CONTINUOUS";
    layer.color = 1; // Red
    writer->writeLayer(&layer);
    
    // 创建伸缩缝图层
    layer.name = "Curves";
    layer.lineType = "CONTINUOUS";
    layer.color = 2; // Yellow
    writer->writeLayer(&layer);
}

void DwgExporter::writeBlockRecords() {}
void DwgExporter::writeBlocks() {}
void DwgExporter::writeDimstyles() {}
void DwgExporter::writeVports() {}
void DwgExporter::writeTextstyles() {}
void DwgExporter::writeAppId() {}
void DwgExporter::writeObjects() {}

void DwgExporter::exportHeatingCoil(const HeatingCoil& coil) {
    // 导出伸缩缝
    exportCurveInfo(coil.Expansions);

    // 导出分集水器回路
    for (const auto& collector : coil.CollectorCoils) {
        exportCollectorCoil(collector);
    }
}

void DwgExporter::exportCollectorCoil(const CollectorCoil& collector) {
    // 导出入户管道
    for (const auto& delivery : collector.Deliverys) {
        exportCurveInfo(delivery);
    }

    // 导出盘管回路
    for (const auto& loop : collector.CoilLoops) {
        exportCoilLoop(loop);
    }
}

void DwgExporter::exportCoilLoop(const CoilLoop& loop) {
    // 创建多段线对象来表示盘管路径
    DRW_LWPolyline polyline;
    polyline.layer = "CoilLoop";
    polyline.flags = 1; // Closed polyline
    polyline.width = 0.5; // Line width
    
    // 设置盘管路径的点
    for (const auto& curve : loop.Path) {
        if (curve.CurveType == 0) { // 直线
            DRW_Vertex2D vertex1;
            vertex1.x = curve.StartPoint.x;
            vertex1.y = curve.StartPoint.y;
            vertex1.bulge = 0;
            
            DRW_Vertex2D vertex2;
            vertex2.x = curve.EndPoint.x;
            vertex2.y = curve.EndPoint.y;
            vertex2.bulge = 0;
            
            polyline.addVertex(vertex1);
            polyline.addVertex(vertex2);
        } else { // 圆弧
            // 处理圆弧，将圆弧离散化为多个点
            double angle = curve.StartAngle;
            const int segments = 16; // 将圆弧分成16段
            double angleStep = (curve.EndAngle - curve.StartAngle) / segments;
            
            for (int i = 0; i <= segments; ++i) {
                double x = curve.Center.x + curve.Radius * cos(angle);
                double y = curve.Center.y + curve.Radius * sin(angle);
                
                DRW_Vertex2D vertex;
                vertex.x = x;
                vertex.y = y;
                vertex.bulge = 0;
                
                polyline.addVertex(vertex);
                angle += angleStep;
            }
        }
    }

    // 写入多段线
    writer->writeLWPolyline(&polyline);
}

void DwgExporter::exportCurveInfo(const std::vector<CurveInfo>& curves) {
    // 创建多段线对象
    DRW_LWPolyline polyline;
    polyline.layer = "Curves";
    polyline.flags = 0; // Open polyline
    polyline.width = 0.3; // Line width
    
    // 添加所有点
    for (const auto& curve : curves) {
        if (curve.CurveType == 0) { // 直线
            DRW_Vertex2D vertex1;
            vertex1.x = curve.StartPoint.x;
            vertex1.y = curve.StartPoint.y;
            vertex1.bulge = 0;
            
            DRW_Vertex2D vertex2;
            vertex2.x = curve.EndPoint.x;
            vertex2.y = curve.EndPoint.y;
            vertex2.bulge = 0;
            
            polyline.addVertex(vertex1);
            polyline.addVertex(vertex2);
        } else { // 圆弧
            // 处理圆弧，将圆弧离散化为多个点
            double angle = curve.StartAngle;
            const int segments = 16; // 将圆弧分成16段
            double angleStep = (curve.EndAngle - curve.StartAngle) / segments;
            
            for (int i = 0; i <= segments; ++i) {
                double x = curve.Center.x + curve.Radius * cos(angle);
                double y = curve.Center.y + curve.Radius * sin(angle);
                
                DRW_Vertex2D vertex;
                vertex.x = x;
                vertex.y = y;
                vertex.bulge = 0;
                
                polyline.addVertex(vertex);
                angle += angleStep;
            }
        }
    }

    // 写入多段线
    writer->writeLWPolyline(&polyline);
}
